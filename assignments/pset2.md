# Pset 2

---

## Concept Questions

1. Contexts. The NonceGeneration concept ensures that the short strings it generates will be unique and not result in conflicts. What are the contexts for, and what will a context end up being in the URL shortening app?

The context is used for storing all other suffixes/nonces used or even returned prior to the current one. In the URL shortening app, the context would likely end up being a set of suffixes, as you wouldn't want to reuse URLs, as otherwise a targetURL that's supposed to connect to a shortURL would end up broken. The context will represent the shortURLBases, however, since the same suffix can be used for multiple bases, thus would need differing contexts.

2. Storing used strings. Why must the NonceGeneration store sets of used strings? One simple way to implement the NonceGeneration is to maintain a counter for each context and increment it every time the generate action is called. In this case, how is the set of used strings in the specification related to the counter in the implementation? (In abstract data type lingo, this is asking you to describe an abstraction function.)

It needs to store sets of used strings because there may be different contexts for certain suffixes that can be used twice, and so within a context the URL will remain unique. For instance, if there are 2 contexts for 2 base URL domains, then you can have a tiny.com/myurl and a shorter.com/myurl. MyURL here can be used twice and shouldn't be in the same context because ultimately they'll be different links.

The set of used strings in the spec is related to the counter as the counter will be however many nonces have been generated for a certain context. The counter could also be used as a way to see if they are going to run out of suffixes based on the number of possible suffixes, so an admin can fix it. AF(counter, usedStrings) = A NonceGeneration with a set of contexts, with all of those contexts containing nonces that cannot be generated again (usedStrings), and a counter to represent how many nonces have already been generated and cannot be used again.

3. Words as nonces. One option for nonce generation is to use common dictionary words (in the style of yellkey.com, for example) resulting in more easily remembered shortenings. What is one advantage and one disadvantage of this scheme, both from the perspective of the user? How would you modify the NonceGeneration concept to realize this idea?

Advantage: A string like "DogAndCat" is a lot more memorable and thus can be typed way faster than a string like "aP6fG!k8^", even though they are the same exact amount of characters. Thus, users would probably find "DogAndCat" more preferable to "aP6fG!k8^".

Disadvantage: Although "Dogs" is very memorable, it severely limits the amount of nonces that can be generated by the app. For example, in Scrabble, there are only [5,663 valid four-letter words](https://scrabble.collinsdictionary.com/word-lists/four-letter-words-in-scrabble/#:~:text=There%20are%205%2C663%20valid%20four,full%20definitions%20from%20CollinsDictionary.com.), whereas there are [104 different characters on an average keyboard](https://www.computerhope.com/issues/ch001598.htm), which means 104^4 = 116985856 different combinations for random character generated nonces. Quite a drastic difference! This would mean there would not be as many URLs to give out to users, and if they all ran out, a user couldn't use the app until a link expired or was deleted, which would be extremely frusturating for them.

In order to modify NonceGeneration to support common dictionary nonces, for its new state I would have a set of Contexts with a counter, a set of usedWords, and a set of usableWords. The counter, Context, and usedWords (from set of strings) would work essentially the same, except when the generate action is performed, it selects a random word from usableWords, removes it from usableWords, then adds it to usedWords, and returns it. Then, when a usedWord suffix expires/is deleted, it'll remove the word from usedWords and add it back to usableWords. This prevents it from getting stuck in infinite loops of trying to select a word from a generic dictionary, but all of them are already used, so it just keeps trying. In my design, if usableWords runs out, the generate action will stop trying to select a word.

---

## Synchronizations for URL Shortening: Synchronization Questions

1. Partial matching. In the first sync (called generate), the Request.shortenUrl action in the when clause includes the shortUrlBase argument but not the targetUrl argument. In the second sync (called register) both appear. Why is this?

2. Omitting names. The convention that allows names to be omitted when argument or result names are the same as their variable names is convenient and allows for a more succinct specification. Why isn’t this convention used in every case?

3. Inclusion of request. Why is the request action included in the first two syncs but not the third one?

4. Fixed domain. Suppose the application did not support alternative domain names, and always used a fixed one such as “bit.ly.” How would you change the synchronizations to implement this?
Adding a sync. These synchronizations are not complete; in particular, they don’t do anything when a resource expires. Write a sync for this case, using appropriate actions from the ExpiringResource and URLShortening concepts.

---

## Extending the design


### Additional concepts


### 3 Essential Syncs


### Feature Requests
